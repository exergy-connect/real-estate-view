<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Houston Crime Heat Map 2025</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <!-- Leaflet Heat Plugin CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.css" />
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Leaflet Heat Plugin JS -->
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            padding: 20px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            height: calc(100vh - 40px);
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #c0392b 0%, #e74c3c 50%, #c0392b 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            opacity: 0.95;
            font-size: 1.1em;
        }

        .controls {
            background: #f8f9fa;
            padding: 20px;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-weight: 600;
            font-size: 0.9em;
            color: #495057;
        }

        .control-group select,
        .control-group input[type="range"] {
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 0.95em;
        }

        .stats {
            background: #f8f9fa;
            padding: 15px 20px;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
        }

        .stat-label {
            font-size: 0.85em;
            color: #6c757d;
            margin-bottom: 3px;
        }

        .stat-value {
            font-size: 1.3em;
            font-weight: 700;
            color: #c0392b;
        }

        .map-container {
            position: relative;
            flex: 1;
            width: 100%;
            min-height: 0;
        }

        #map {
            height: 100%;
            width: 100%;
        }

        .legend {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            font-size: 14px;
            min-width: 200px;
        }

        .legend h3 {
            margin-bottom: 10px;
            color: #333;
            font-size: 1.1em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-right: 10px;
            border: 1px solid #ccc;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px 40px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 2000;
            font-size: 1.1em;
            color: #333;
        }

        .loading::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ”¥ Houston Crime Heat Map 2025</h1>
            <p>Interactive visualization of crime incidents reported in Houston, Texas</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="crimeTypeFilter">Crime Type</label>
                <select id="crimeTypeFilter">
                    <option value="">All Crimes</option>
                </select>
            </div>
            <div class="control-group">
                <label for="intensitySlider">Heat Intensity</label>
                <input type="range" id="intensitySlider" min="0.1" max="2.0" step="0.1" value="1.0">
                <span id="intensityValue">1.0</span>
            </div>
            <div class="control-group">
                <label for="radiusSlider">Point Radius</label>
                <input type="range" id="radiusSlider" min="5" max="50" step="5" value="25">
                <span id="radiusValue">25</span>
            </div>
        </div>

        <div class="stats">
            <div class="stat-item">
                <span class="stat-label">Total Incidents</span>
                <span class="stat-value" id="totalIncidents">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Displayed</span>
                <span class="stat-value" id="displayedIncidents">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">With Coordinates</span>
                <span class="stat-value" id="withCoordinates">0</span>
            </div>
        </div>

        <div class="map-container">
            <div id="map"></div>
            <div class="loading" id="loadingIndicator">Loading crime data</div>
            <div class="legend" id="legend" style="display: none;">
                <h3>Heat Map Intensity</h3>
                <div class="legend-item">
                    <div class="legend-color" style="background: #00ff00;"></div>
                    <span>Low</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffff00;"></div>
                    <span>Medium</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff0000;"></div>
                    <span>High</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Load consolidated data -->
    <script src="output/consolidated_data.js"></script>
    
    <script>
        let map;
        let heatLayer = null;
        let markerLayer = null; // Layer group for individual crime markers
        let allCrimeData = [];
        let filteredCrimeData = [];
        let crimeTypes = new Set();
        const MAX_MARKERS_FOR_TOOLTIPS = 100; // Show individual markers when <= 100 visible

        // Initialize map
        function initMap() {
            // Center on Houston area
            map = L.map('map').setView([29.7604, -95.3698], 11);
            
            // Add OpenStreetMap tiles
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);
            
            // Create marker layer group
            markerLayer = L.layerGroup().addTo(map);
            
            // Listen for zoom and move events to update display mode
            map.on('zoomend moveend', updateDisplayMode);
        }

        // Load and process crime data
        async function loadCrimeData() {
            const loadingIndicator = document.getElementById('loadingIndicator');
            
            try {
                // Use the async function from consolidated_data.js
                const data = await getConsolidatedData();
                
                // Extract data - crime_incident may be nested under crime_zipcode
                const crimeIncidents = data.data?.crime_incident || {};
                const crimeZipcodes = data.data?.crime_zipcode || {};
                const nibrsClasses = data.data?.nibrs_class || {};
                
                // Process all incidents (both flat and nested)
                let totalIncidents = 0;
                let incidentsWithCoords = 0;
                
                // Helper function to process a single incident
                function processIncident(incident, nibrsClasses) {
                    // Filter for 2025 data
                    const occurrenceDate = incident.occurrence_date;
                    if (!occurrenceDate || !occurrenceDate.startsWith('2025')) {
                        return;
                    }
                    
                    // Check if incident has coordinates
                    const lat = incident.map_latitude;
                    const lng = incident.map_longitude;
                    
                    if (lat && lng && !isNaN(lat) && !isNaN(lng)) {
                        incidentsWithCoords++;
                        
                        // Get crime type description
                        const nibrsClass = incident.nibrs_class;
                        let crimeType = 'Unknown';
                        if (nibrsClass && nibrsClasses) {
                            const nibrsClassData = nibrsClasses[nibrsClass];
                            if (nibrsClassData && nibrsClassData.description) {
                                crimeType = nibrsClassData.description;
                            }
                        }
                        
                        crimeTypes.add(crimeType);
                        
                        allCrimeData.push({
                            lat: parseFloat(lat),
                            lng: parseFloat(lng),
                            type: crimeType,
                            date: occurrenceDate,
                            incident: incident.incident
                        });
                    }
                }
                
                // Process flat crime_incident entities
                for (const [pk, incident] of Object.entries(crimeIncidents)) {
                    totalIncidents++;
                    processIncident(incident, nibrsClasses);
                }
                
                // Process nested crime_incident entities under crime_zipcode
                for (const [zipcode, zipcodeData] of Object.entries(crimeZipcodes)) {
                    if (zipcodeData.incidents && Array.isArray(zipcodeData.incidents)) {
                        zipcodeData.incidents.forEach(incident => {
                            totalIncidents++;
                            processIncident(incident, nibrsClasses);
                        });
                    }
                }

                // Update statistics
                document.getElementById('totalIncidents').textContent = totalIncidents.toLocaleString();
                document.getElementById('withCoordinates').textContent = incidentsWithCoords.toLocaleString();
                
                // Populate crime type filter
                const crimeTypeFilter = document.getElementById('crimeTypeFilter');
                const sortedTypes = Array.from(crimeTypes).sort();
                sortedTypes.forEach(type => {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = type;
                    crimeTypeFilter.appendChild(option);
                });

                // Initial display
                filteredCrimeData = allCrimeData;
                // Wait a bit for map to be ready, then update display
                setTimeout(() => {
                    updateDisplayMode();
                }, 100);
                
                loadingIndicator.style.display = 'none';
                document.getElementById('legend').style.display = 'block';
                
            } catch (error) {
                console.error('Error loading crime data:', error);
                loadingIndicator.textContent = 'Error loading data: ' + error.message;
            }
        }

        // Get crimes visible in current map bounds
        function getVisibleCrimes() {
            if (!map) return [];
            
            const bounds = map.getBounds();
            return filteredCrimeData.filter(crime => {
                return bounds.contains([crime.lat, crime.lng]);
            });
        }

        // Create individual markers with tooltips
        function createIndividualMarkers(visibleCrimes) {
            // Clear existing markers
            markerLayer.clearLayers();
            
            visibleCrimes.forEach(crime => {
                const marker = L.circleMarker([crime.lat, crime.lng], {
                    radius: 5,
                    fillColor: '#e74c3c',
                    color: '#c0392b',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.7
                });
                
                // Create tooltip content
                const tooltipContent = `
                    <div style="font-size: 12px; min-width: 150px;">
                        <strong>${crime.type || 'Unknown Crime'}</strong><br>
                        Date: ${crime.date || 'N/A'}<br>
                        Incident: ${crime.incident || 'N/A'}
                    </div>
                `;
                
                marker.bindTooltip(tooltipContent, {
                    permanent: false,
                    direction: 'top',
                    offset: [0, -5]
                });
                
                marker.addTo(markerLayer);
            });
        }

        // Update display mode based on visible crime count
        function updateDisplayMode() {
            const visibleCrimes = getVisibleCrimes();
            const visibleCount = visibleCrimes.length;
            
            if (visibleCount <= MAX_MARKERS_FOR_TOOLTIPS && visibleCount > 0) {
                // Show individual markers with tooltips
                if (heatLayer) {
                    map.removeLayer(heatLayer);
                    heatLayer = null;
                }
                createIndividualMarkers(visibleCrimes);
                document.getElementById('displayedIncidents').textContent = visibleCount.toLocaleString();
            } else {
                // Show heat layer
                markerLayer.clearLayers();
                updateHeatMap();
            }
        }

        // Update heat map (called when showing heat layer, not individual markers)
        function updateHeatMap() {
            // Remove existing heat layer
            if (heatLayer) {
                map.removeLayer(heatLayer);
            }

            if (filteredCrimeData.length === 0) {
                document.getElementById('displayedIncidents').textContent = '0';
                return;
            }

            // Prepare heat map points
            const heatPoints = filteredCrimeData.map(crime => [
                crime.lat,
                crime.lng,
                1.0 // intensity
            ]);

            // Get intensity and radius from sliders
            const intensity = parseFloat(document.getElementById('intensitySlider').value);
            const radius = parseInt(document.getElementById('radiusSlider').value);

            // Create heat layer
            heatLayer = L.heatLayer(heatPoints, {
                radius: radius,
                blur: radius * 0.8,
                maxZoom: 17,
                max: intensity,
                gradient: {
                    0.0: 'blue',
                    0.2: 'cyan',
                    0.4: 'lime',
                    0.6: 'yellow',
                    0.8: 'orange',
                    1.0: 'red'
                }
            }).addTo(map);

            // Update displayed count (total filtered, not just visible)
            document.getElementById('displayedIncidents').textContent = filteredCrimeData.length.toLocaleString();
        }

        // Filter by crime type
        document.getElementById('crimeTypeFilter').addEventListener('change', function() {
            const selectedType = this.value;
            if (selectedType === '') {
                filteredCrimeData = allCrimeData;
            } else {
                filteredCrimeData = allCrimeData.filter(crime => crime.type === selectedType);
            }
            updateDisplayMode();
        });

        // Update intensity
        document.getElementById('intensitySlider').addEventListener('input', function() {
            document.getElementById('intensityValue').textContent = this.value;
            // Only update heat map if we're showing heat layer, not individual markers
            const visibleCrimes = getVisibleCrimes();
            if (visibleCrimes.length > MAX_MARKERS_FOR_TOOLTIPS || visibleCrimes.length === 0) {
                updateHeatMap();
            }
        });

        // Update radius
        document.getElementById('radiusSlider').addEventListener('input', function() {
            document.getElementById('radiusValue').textContent = this.value;
            // Only update heat map if we're showing heat layer, not individual markers
            const visibleCrimes = getVisibleCrimes();
            if (visibleCrimes.length > MAX_MARKERS_FOR_TOOLTIPS || visibleCrimes.length === 0) {
                updateHeatMap();
            }
        });

        // Initialize
        initMap();
        
        // Load data (getConsolidatedData is async, so we can call it directly)
        loadCrimeData();
    </script>
</body>
</html>
